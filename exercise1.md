A team of six developers are developing a Ruby on Rails application and their source code is being hosted on the company's own GitLab server. The application will be hosted on Heroku. They have set up a GitLab pipeline for rails (a GitLab runner), which includes three stages:
- build
- test
- deploy

In the build stage, the code is checked whether it meets the current coding standards and that there aren't any errors when compiling. The second phase tests the application in many different ways, by doing security tests on the application, security tests on the packages, unit tests etc. The third step deploys the application to Heroku depending on the target environment.

They currently have two Heroku applications / environments. One for testing (test environment) and one for production. They also have three permanent branches on GitLab, a test branch, a staging branch and a master branch. When a commit is merged into the test branch and pushed to the versioning control server, the test pipeline is automatically run and the change is deployed to the Heroku test environment (if the pipeline succeeds). When a new feature or a bug fix is developed, a new branch is created for this. When the job on that is done, it is tested in the test environment, a merge request to the staging branch is created, the request is reviewed by some of the other developers on the team, and when the review passes, the branch is merged into the staging branch. Unlike the test branch, a merge to the staging branch does not cause an automatic deployment to the production environment. When the production deployment is needed, a merge request from staging to the master branch is created. When the branch is merged, a production pipeline starts, and if all succeeds, the production environment is updated with the changes in the master branch. The master branch should always have the same status as the production environment.